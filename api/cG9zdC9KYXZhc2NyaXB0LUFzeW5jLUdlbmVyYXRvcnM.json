{"title":"Javascript在异步中背后都做了什么","date":"2019-01-25T19:40:39.000Z","slug":"Javascript-Async-Generators","updated":"2019-01-25T20:03:33.780Z","content":"<div class=\"article-img\"><p><img src=\"https://www.allthingsdistributed.com/images/stockholm.jpg\" alt=\"image\"></p></div>\n<p>表面上的风平浪静,往往暗涛汹涌.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doWhenDataReceived</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  returnNextElement.next(value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">createFlow</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> data = <span class=\"keyword\">yield</span> fetch(<span class=\"string\">'https://twitter.com/1'</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> returnNextElement = createFlow();</span><br><span class=\"line\"><span class=\"keyword\">const</span> futureData = returnNextElement.next();</span><br><span class=\"line\">futureData.then(doWhenDataReceived);</span><br></pre></td></tr></table></figure></p>\n<p>上面的代码讲述了异步请求 twitter api.</p>\n<h3 id=\"memory\"><a href=\"#memory\" class=\"headerlink\" title=\"memory\"></a>memory</h3><p>从上向下观察上述代码,我们知道:<br>声明了 <code>doWhenDataReceived: [function]</code> 与 <code>createFlow: [generator function]</code><br>声明了 <code>const returnNextElement: __</code>与 <code>const futureData: __</code></p>\n<p>注1: 这里的__ 表示为被赋值.在函数调用的时候,初始值是空的.背后是需要经过 call stack 之后才会被赋值(指向).</p>\n<p>注2: const 关键字很多人说是不改变,但是在 JavaScript 中,不可被赋值的描述才准确.比如一个 const 的对象.你修改他的属性,他是不会有任何异常抛出的.说明一些人的总结是错误的.<br>JavaScript 是不同于其他语言的一门语言.思想与组织完全不同.黑猫白猫一把抓的想法会让你在 JavaScript 的世界中举步维艰.</p>\n<h3 id=\"generator\"><a href=\"#generator\" class=\"headerlink\" title=\"generator\"></a>generator</h3><p>当了解了内存的初始化之后.我们接下来看函数调用.看看 JavaScript 到底帮我们干了什么.<br>首先: returnNextElement = createFlow(),此处并不是没有产生一个压栈,因为 createFlow 是一个 generator function, 产生的是一个<code>{ next: [function] }</code>.即<code>returnNextElement = {next: [function]}</code>指向,产出我们的数据.所以在全局中 returnNextElement 是一个指向 <code>{next: [function]}</code> 的对象.所以这里需要注意一下.并不是说遇到<code>()</code>就一定是函数调用.</p>\n<p>注3: 我们说的函数调用,指的是<code>stack call</code> 调用栈压栈 push,进入 execution context.处理完成.调用栈 pop.</p>\n<h3 id=\"yield-amp-fetch\"><a href=\"#yield-amp-fetch\" class=\"headerlink\" title=\"yield &amp; fetch\"></a>yield &amp; fetch</h3><p>在1ms 的时候发生的情况.futureData = returnNextElement.next()语句,这里是真的调用了 createFlow().调用栈push.调用的就是上面说的那个隐式对象. 随后进入 Execution Context 中:<br>1.在局部变量中声明了 data.<br>2: 执行 fetch. </p>\n<p>在执行fetch时.首先他产生一个<code>{ value: __, unfulfillment: [ ] }</code> promise对象.此时值为空的.unfilfillment是一个隐藏属性,标记着等待接收数据. 而这个对象的作用是等待 value 更新, 当更新后, unfulfillment 会被自动调用绑定函数同时把 value 传入. 遇到 yield 这个类似 return 的时候,会暂停并返回.此时的 fetchData 指向的是一个空的 promise 对象,即全局中我们看到的 fetchData = { value: __, unfulfillment: [ ] },<code>等待浏览器将请求结果填充给 value 传回给 JavaScript</code>.</p>\n<p>注4: yield 会暂停返回,当下一个调用参数入参数的时候,会在暂停处继续向下执行.有时候我们看到如 内部 x = yield 3. 外部 z.next(2), 内部的x 的值指向2,就是这个原因.</p>\n<h3 id=\"web-browser-future\"><a href=\"#web-browser-future\" class=\"headerlink\" title=\"web browser future\"></a>web browser future</h3><p>接下来我们就来说请求去了哪里.在 fetch 生成 promise 并被暂停抛出的时候.同时还发生了另一件事情,触发了浏览器的 XMLHTTPRequest请求,简称 XHR.带着目的host, path, method 去 twitter 服务器请求我们需要的 API 数据,即<code>GET https://twitter.com/1</code>. 经过各层加头,各层解头,目标服务器事件处理这些我们略去不讲.</p>\n<p>此时的 web browser feature 中维护着一个请求complete状态,请求开始,被标记为未完成,意味着我们的请求未完成.这里需要注意的是,此时已经和 JavaScript 没有关系了.属于浏览器功能.</p>\n<p>我们知道,futureData.value 正在web browser future中等待值更新.更新后自动调用所需的 function,这里是 doWhenDataReceived.</p>\n<h3 id=\"final\"><a href=\"#final\" class=\"headerlink\" title=\"final\"></a>final</h3><p>设100ms 之后,API 请求成功.浏览器将 complete 被标记为完成. 浏览器会将请求结果给到 futureData.value.这个时候会将 value 传入到自动调用unfulfillment下的 function中并放入到 microtask queue 中等待 event loop 轮询的调用栈的情况,当调用栈为空时,会优先将 microtask queue 中的等待方法压入调用栈中.被压入的方法形成一个新的execution context.也就是我们说的 doWhenDataReceived(result) 调用. 在 execution context 中,returnNextElement.next(result)会携带着返回的结果回到刚才的 yield 中. 注4已说明.也就是说yield 表达式的结果是 result.即 data=result.到这里也就结束了在这段代码中的异步的所有事情.终于得到了我们想要的输出结果.</p>\n<p>注5: microtask queue 的优先级是高于 call queue 的.event loop 会先判断 call stack 是否为空.当然 global 忽略,然后会优先执行 microtask queue,最后是 call stack 队列.所以有时候你会看到 fetch 与 setTimeout(fn, 0) 在 fetch 100ms 后才出现的原因.</p>\n<h3 id=\"summary\"><a href=\"#summary\" class=\"headerlink\" title=\"summary\"></a>summary</h3><p>果然用一篇小短文去讲述异步背后的事情有点难.在一个异步代码中, 涉及了 promise, XHR, generators, event loop, microtask, yield等等等等.我第一次看到模型全貌的时候,由衷的惊叹实在是太美了.同时也挖出了很多天坑,如 yield 的中断与执行背后发生的事情,再比如说 event loop 与 call queue 的关系.恩,说到 el 与 cq,不得不说我们常见的一个闭包 setTimeout 的那个例子. 很多人只是阐述为什么会在循环中变成同一个数,只是说延迟执行了.具体怎么延迟的.</p>\n<h3 id=\"aha\"><a href=\"#aha\" class=\"headerlink\" title=\"aha\"></a>aha</h3><p>ECMAScript Spec 超级好的一个东西!<br>ECMAScript Spec 超级好的一个东西!!<br>ECMAScript Spec 超级好的一个东西!!!</p>\n<p>That’s all.</p>\n","next":{"title":"Hello World","slug":"hello-world"},"link":"http://yoursite.com/post/Javascript-Async-Generators/"}